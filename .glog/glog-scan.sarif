{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-77cc2da2-b642-4c5c-825d-a9373c5471c6",
              "name": "OpensslHardcodedSsltlsProtocol",
              "shortDescription": {
                "text": "OpenSSL: Hard-coded SSL/TLS Protocol"
              },
              "fullDescription": {
                "text": "OpenSSL: Hard-coded SSL/TLS Protocol: OpenSSL: Hard-coded SSL/TLS Protocol"
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "note"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440001.md",
              "help": {
                "text": "Review to ensure that a TLS protocol agility is maintained.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440001.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440001.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "ManualReview",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "recommendation",
                "tags": [
                  "DS440011"
                ]
              }
            },
            {
              "id": "glog-fb4f09c9-c03f-4288-98b3-c46bce2966fa",
              "name": "OpensslDoNotHardcodeSsltlsVersionsWithinAnApplication",
              "shortDescription": {
                "text": "SSL/TLS version usage should be based on an OS or external configuration."
              },
              "fullDescription": {
                "text": "OpenSSL: Do not hardcode SSL/TLS versions within an application.: SSL/TLS version usage should be based on an OS or external configuration."
              },
              "defaultConfiguration": {
                "enabled": true,
                "level": "error"
              },
              "helpUri": "https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md",
              "help": {
                "text": "SSL/TLS version usage should be based on an OS or external configuration.",
                "markdown": "Visit [https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md](https://github.com/Microsoft/DevSkim/blob/main/guidance/DS440000.md) for guidance on this issue."
              },
              "properties": {
                "DevSkimSeverity": "Important",
                "DevSkimConfidence": "High",
                "precision": "high",
                "problem.severity": "warning",
                "tags": [
                  "DS440010"
                ]
              }
            },
            {
              "id": "glog-766be720-eaf0-4d15-bfc9-22d2cef6d4f1",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen()` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen()` will continue reading memory until it encounters a null character, potentially leading to buffer overflows, memory corruption, and other undefined behavior.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that strings are null-terminated before passing them to `strlen()`. Additionally, consider using safer alternatives such as `strnlen()`, which takes an additional parameter specifying the maximum number of characters to read. This can prevent buffer overflows if the string is not null-terminated.\n\n## Source Code Fix Recommendation\n\nInstead of:\n\n```c++\nsize_t len = strlen(uri);\n```\n\nUse:\n\n```c++\nsize_t len = strnlen(uri, MAX_LEN);\n```\n\nWhere `MAX_LEN` is the maximum expected length of the string. This ensures that `strnlen()` will not read past the end of the buffer, even if `uri` is not null-terminated.\n\n## Library Dependencies\n\nThe `strlen()` function is part of the C standard library, so no additional libraries are needed.\n\n## References\n\n- [OWASP C/C++ Vulnerabilities](https://owasp.org/www-pdf-archive/OWASP_SCP_Quick_Reference_Guide_v2.pdf)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)\n\nPlease note that the links provided are accessible to anonymous users at the time of writing this report."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-fb75442c-3099-4e77-8641-6eeae60e7797",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially when randomness is critical for security purposes. The `rand()` function is not suitable for cryptographic purposes because it produces predictable sequences of numbers if the seed is known or can be guessed. This can lead to vulnerabilities in applications where randomness is used for generating keys, tokens, or any other security-related data.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator (CSPRNG) instead of `rand()`. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers with better randomness properties.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand() %` with a more secure random number generation approach using the `<random>` library. Below is an example of how to replace `rand()` with a CSPRNG:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister engine\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define the range for random numbers\n    std::uniform_int_distribution<> dis(0, 99); // Example range [0, 99]\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library is required:\n\n- `<random>`: This is part of the C++ Standard Library and does not require any additional dependencies beyond a standard C++ compiler that supports C++11 or later.\n\n### Relevant Links\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-c8121521-5cf7-48da-9f14-ac93390ba6a8",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe `strlen` function in C and C++ is used to find the length of a string. However, it can lead to vulnerabilities if not used properly. The function counts the number of characters in a string until it reaches a null character (`'\\0'`). If the string is not null-terminated, `strlen` will continue reading memory until it encounters a null character, potentially leading to buffer over-read, information leakage, or even a segmentation fault.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, always ensure that your strings are null-terminated. This can be done by initializing your strings with a null character at the end, or by manually adding a null character at the end of your string after you have finished manipulating it.\n\nAlso, consider using safer alternatives to `strlen`, such as `strnlen`, which takes an additional parameter specifying the maximum number of characters to read. This can prevent buffer over-reads even if the string is not null-terminated.\n\n## Source Code Fix Recommendation\n\nIf `chunk_str` is a null-terminated string, `strlen(chunk_str)` is safe. If not, you should ensure it is null-terminated before calling `strlen`. Here is an example:\n\n```cpp\n#include <cstring>\n\n// Ensure chunk_str is null-terminated\nchar chunk_str[100] = {0};\n\n// Now it's safe to call strlen\nsize_t len = strlen(chunk_str);\n```\n\nOr use `strnlen` instead:\n\n```cpp\n#include <cstring>\n\nchar chunk_str[100];\n\n// strnlen will not read beyond the specified limit\nsize_t len = strnlen(chunk_str, sizeof(chunk_str));\n```\n\n## Library Dependencies\n\nThe `strlen` function is part of the C standard library, so you need to include the `<cstring>` header in C++.\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-03915d9b-bfdb-4f66-a12e-7264371c4fa7",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Use of Obsolete or Prohibited SSL/TLS Protocol\" vulnerability refers to the use of outdated or insecure SSL/TLS protocols in a C++ application. SSLv2 is an example of such a protocol. It is considered insecure and obsolete due to several known vulnerabilities, including weak message authentication, no protection for the handshake, and susceptibility to man-in-the-middle attacks.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, you should:\n\n1. Avoid using SSLv2 and other insecure or obsolete SSL/TLS protocols.\n2. Use the most recent version of TLS (currently TLS 1.3).\n3. Regularly update your libraries to the latest versions, as they often include security improvements and fixes for known vulnerabilities.\n4. Use secure configurations for your SSL/TLS protocols. For example, disable weak ciphers.\n\n## Source Code Fix Recommendation\n\nIf you're using the OpenSSL library, you can specify the protocol version when creating a new SSL context. Here's an example of how to do it:\n\n```cpp\n#include <openssl/ssl.h>\n\nSSL_CTX *ctx = SSL_CTX_new(TLS_method()); // Use TLS_method instead of SSLv2_method\n```\n\n## Library Dependencies\n\nThe above code example requires the OpenSSL library.\n\n## References\n\n- [OWASP Transport Layer Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html)\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS169126"
                ]
              }
            },
            {
              "id": "glog-08e51583-d3c3-4607-a135-a53e572865a2",
              "help": {
                "text": "",
                "markdown": "### Description\n\nIn C++ programming, using weak or non-cryptographic random number generators, such as the `rand()` function, can lead to vulnerabilities, especially in security-sensitive applications. The `rand()` function is not suitable for cryptographic purposes because it generates predictable sequences of numbers if the seed is known. This predictability can be exploited by attackers to compromise the security of the application.\n\n### General Mitigation Advice\n\nTo mitigate this vulnerability, use a cryptographically secure random number generator. In C++, the `<random>` library provides better alternatives, such as `std::random_device` and `std::mt19937`, which can be used to generate random numbers more securely.\n\n### Source Code Fix Recommendation\n\nReplace the use of `rand()` with a more secure random number generator from the `<random>` library. Here is an example of how to do this:\n\n```cpp\n#include <iostream>\n#include <random>\n\nint main() {\n    // Create a random device and a Mersenne Twister random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n\n    // Define a distribution range\n    std::uniform_int_distribution<> dis(1, 100);\n\n    // Generate a random number\n    int random_number = dis(gen);\n\n    std::cout << \"Secure random number: \" << random_number << std::endl;\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example properly, the following library is required:\n\n- `<random>`: This library provides facilities for generating random numbers.\n\n### OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)](https://cwe.mitre.org/data/definitions/338.html)"
              },
              "properties": {
                "tags": [
                  "DS148264"
                ]
              }
            },
            {
              "id": "glog-0a759f72-735d-4264-a25f-df4b839768fa",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Avoid Leaving Debug Code in Production\" vulnerability in C++ arises when developers inadvertently leave debugging code, such as logging, assertions, or test hooks, in the production environment. This can lead to several issues, including performance degradation, information leakage, and unintended behavior. Debug code is typically meant for development and testing purposes and should be removed or disabled in production builds.\n\n### General Mitigation Advice\n\n1. **Code Review**: Conduct thorough code reviews to ensure that debug code is not present in production.\n2. **Build Configurations**: Use different build configurations for development and production. Ensure that debug code is only included in development builds.\n3. **Conditional Compilation**: Use preprocessor directives to include debug code only in non-production builds.\n4. **Automated Tools**: Utilize static analysis tools to detect and flag debug code in the codebase.\n\n### Source Code Fix Recommendation\n\nTo address the specific vulnerability sink `127.0.0.1`, ensure that any debug code related to network operations, such as connecting to localhost for testing, is removed or conditionally compiled out in production builds.\n\n#### Example Code\n\n```cpp\n#include <iostream>\n#include <string>\n\n// Library dependencies\n#include <boost/asio.hpp>\n\nint main() {\n    // Debug code: connecting to localhost\n#ifdef DEBUG\n    std::string debug_ip = \"127.0.0.1\";\n    std::cout << \"Connecting to debug IP: \" << debug_ip << std::endl;\n    // Simulate network operation\n    boost::asio::io_context io_context;\n    boost::asio::ip::tcp::resolver resolver(io_context);\n    boost::asio::ip::tcp::resolver::query query(debug_ip, \"80\");\n    boost::asio::ip::tcp::resolver::iterator endpoint_iterator = resolver.resolve(query);\n    // ... additional debug operations\n#endif\n\n    // Production code\n    std::cout << \"Running production code...\" << std::endl;\n    // ... production operations\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `boost/asio.hpp`: This library is required for network operations in the example code. Ensure that Boost is properly installed and linked in your project.\n\n### Relevant Links\n\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)"
              },
              "properties": {
                "tags": [
                  "DS162092"
                ]
              }
            },
            {
              "id": "glog-289fdd36-30d3-4bfd-b146-1276f407bbbc",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Avoid Leaving Debug Code in Production\" vulnerability in C++ arises when developers inadvertently leave debugging code, such as logging, assertions, or test hooks, in the production environment. This can lead to several issues, including performance degradation, information leakage, and unintended behavior. Debug code is typically meant for development and testing purposes and should be removed or disabled in production builds.\n\n### General Mitigation Advice\n\n1. **Code Review**: Conduct thorough code reviews to ensure that debug code is not present in production.\n2. **Build Configurations**: Use different build configurations for development and production. Ensure that debug code is only included in development builds.\n3. **Conditional Compilation**: Use preprocessor directives to include debug code only in non-production builds.\n4. **Automated Tools**: Utilize static analysis tools to detect and flag debug code in the codebase.\n\n### Source Code Fix Recommendation\n\nTo address the specific vulnerability sink `127.0.0.1`, ensure that any debug code related to network operations, such as connecting to localhost for testing, is removed or conditionally compiled out in production builds.\n\n#### Example Code\n\n```cpp\n#include <iostream>\n#include <string>\n\n// Library dependencies\n#include <boost/asio.hpp>\n\nint main() {\n    // Debug code: connecting to localhost\n#ifdef DEBUG\n    std::string debug_ip = \"127.0.0.1\";\n    std::cout << \"Connecting to debug IP: \" << debug_ip << std::endl;\n    // Simulate network operation\n    boost::asio::io_context io_context;\n    boost::asio::ip::tcp::resolver resolver(io_context);\n    boost::asio::ip::tcp::resolver::query query(debug_ip, \"80\");\n    boost::asio::ip::tcp::resolver::iterator endpoint_iterator = resolver.resolve(query);\n    // ... additional debug operations\n#endif\n\n    // Production code\n    std::cout << \"Running production code...\" << std::endl;\n    // ... production operations\n\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `boost/asio.hpp`: This library is required for network operations in the example code. Ensure that Boost is properly installed and linked in your project.\n\n### Relevant Links\n\n- [CWE-489: Leftover Debug Code](https://cwe.mitre.org/data/definitions/489.html)"
              },
              "properties": {
                "tags": [
                  "DS162092"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-77cc2da2-b642-4c5c-825d-a9373c5471c6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "OpenSSL: Hard-coded SSL/TLS Protocol"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "libevhtp/libevhtp/examples/test.c"
                },
                "region": {
                  "startLine": 628,
                  "startColumn": 34,
                  "endLine": 628,
                  "endColumn": 49,
                  "charOffset": 18085,
                  "charLength": 15,
                  "snippet": {
                    "text": "SSL_OP_NO_SSLv2",
                    "rendered": {
                      "text": "SSL_OP_NO_SSLv2",
                      "markdown": "`SSL_OP_NO_SSLv2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.Protocol.TLS.Hard-Coded"
            ]
          }
        },
        {
          "ruleId": "glog-fb4f09c9-c03f-4288-98b3-c46bce2966fa",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "OpenSSL: Do not hardcode SSL/TLS versions within an application."
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "libevhtp/libevhtp/examples/test.c"
                },
                "region": {
                  "startLine": 628,
                  "startColumn": 34,
                  "endLine": 628,
                  "endColumn": 47,
                  "charOffset": 18085,
                  "charLength": 13,
                  "snippet": {
                    "text": "SSL_OP_NO_SSL",
                    "rendered": {
                      "text": "SSL_OP_NO_SSL",
                      "markdown": "`SSL_OP_NO_SSL`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.Protocol.TLS.Hardcoded"
            ]
          }
        },
        {
          "ruleId": "glog-766be720-eaf0-4d15-bfc9-22d2cef6d4f1",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "libevhtp/libevhtp/examples/test.c"
                },
                "region": {
                  "startLine": 170,
                  "startColumn": 13,
                  "endLine": 170,
                  "endColumn": 24,
                  "charOffset": 4727,
                  "charLength": 11,
                  "snippet": {
                    "text": "strlen(uri)",
                    "rendered": {
                      "text": "strlen(uri)",
                      "markdown": "`strlen(uri)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "libevhtp/libevhtp/examples/test.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4727,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strlen_s(uri, <size of uri>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "libevhtp/libevhtp/examples/test.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4727,
                        "charLength": 11
                      },
                      "insertedContent": {
                        "text": "strnlen(uri, <size of uri>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-fb75442c-3099-4e77-8641-6eeae60e7797",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Avoid Using Weak or Non-Cryptographic Random Number Generators\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "libevhtp/libevhtp/examples/test.c"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 28,
                  "endLine": 49,
                  "endColumn": 36,
                  "charOffset": 1210,
                  "charLength": 8,
                  "snippet": {
                    "text": "rand() %",
                    "rendered": {
                      "text": "rand() %",
                      "markdown": "`rand() %`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-c8121521-5cf7-48da-9f14-ac93390ba6a8",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Detected Vulnerability in C Function (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "libevhtp/libevhtp/examples/test.c"
                },
                "region": {
                  "startLine": 229,
                  "startColumn": 37,
                  "endLine": 229,
                  "endColumn": 54,
                  "charOffset": 6171,
                  "charLength": 17,
                  "snippet": {
                    "text": "strlen(chunk_str)",
                    "rendered": {
                      "text": "strlen(chunk_str)",
                      "markdown": "`strlen(chunk_str)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "libevhtp/libevhtp/examples/test.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6171,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strlen_s(chunk_str, <size of chunk_str>)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "libevhtp/libevhtp/examples/test.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 6171,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strnlen(chunk_str, <size of chunk_str>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-03915d9b-bfdb-4f66-a12e-7264371c4fa7",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Use of Obsolete or Prohibited SSL/TLS Protocol"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "libevhtp/libevhtp/examples/test.c"
                },
                "region": {
                  "startLine": 628,
                  "startColumn": 44,
                  "endLine": 628,
                  "endColumn": 49,
                  "charOffset": 18095,
                  "charLength": 5,
                  "snippet": {
                    "text": "SSLv2",
                    "rendered": {
                      "text": "SSLv2",
                      "markdown": "`SSLv2`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.Protocol.Banned"
            ]
          }
        },
        {
          "ruleId": "glog-08e51583-d3c3-4607-a135-a53e572865a2",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "\"Avoid Using Weak or Non-Cryptographic Random Number Generators\""
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "libevhtp/libevhtp/examples/test.c"
                },
                "region": {
                  "startLine": 49,
                  "startColumn": 28,
                  "endLine": 49,
                  "endColumn": 33,
                  "charOffset": 1210,
                  "charLength": 5,
                  "snippet": {
                    "text": "rand(",
                    "rendered": {
                      "text": "rand(",
                      "markdown": "`rand(`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.PRNG.Weak"
            ]
          }
        },
        {
          "ruleId": "glog-0a759f72-735d-4264-a25f-df4b839768fa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Avoid Leaving Debug Code in Production"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "libevhtp/libevhtp/examples/example_pause.c"
                },
                "region": {
                  "startLine": 107,
                  "startColumn": 26,
                  "endLine": 107,
                  "endColumn": 35,
                  "charOffset": 3263,
                  "charLength": 9,
                  "snippet": {
                    "text": "127.0.0.1",
                    "rendered": {
                      "text": "127.0.0.1",
                      "markdown": "`127.0.0.1`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Hygiene.Network.AccessingLocalhost"
            ]
          }
        },
        {
          "ruleId": "glog-289fdd36-30d3-4bfd-b146-1276f407bbbc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Avoid Leaving Debug Code in Production"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "libevhtp/libevhtp/examples/example_request_fini.c"
                },
                "region": {
                  "startLine": 57,
                  "startColumn": 26,
                  "endLine": 57,
                  "endColumn": 35,
                  "charOffset": 1674,
                  "charLength": 9,
                  "snippet": {
                    "text": "127.0.0.1",
                    "rendered": {
                      "text": "127.0.0.1",
                      "markdown": "`127.0.0.1`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "ManualReview",
            "DevSkimConfidence": "High",
            "tags": [
              "Hygiene.Network.AccessingLocalhost"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}